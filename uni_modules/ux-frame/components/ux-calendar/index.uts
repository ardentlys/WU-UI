import { $ux } from '../../index.uts'
import { UXCalendarEvent, UXCalendarDate } from '../../libs/types/types.uts'
import { Calendar } from '../../libs/fun/calendar.uts'

type CoordsType = {
	x : number;
	y : number;
	width : number;
	height : number;
	data : UXCalendarDate
}

export const UxCalendarMixin = defineMixin({
	emits: ['change', 'click'],
	data() {
		return {
			eleIndex: 0,
			weekEle: null as null | Element,
			month0Ele: null as null | Element,
			month1Ele: null as null | Element,
			month2Ele: null as null | Element,
			
			// TODO 缺失 CanvasContext
			month0Ctx: null as any | null,
			month1Ctx: null as any | null,
			month2Ctx: null as any | null,
			
			month0ID: `month0-${$ux.Random.uuid()}`,
			month1ID: `month1-${$ux.Random.uuid()}`,
			month2ID: `month2-${$ux.Random.uuid()}`,
	
			weeks: [] as Array<Array<UXCalendarDate>>,
			nextWeeks: [] as Array<Array<UXCalendarDate>>,
			lastWeeks: [] as Array<Array<UXCalendarDate>>,
			
			weekDays: ['一', '二', '三', '四', '五', '六', '日'],
	
			coords: [] as Array<CoordsType>,
	
			timeData: {
				_date: new Date(),
				fullDate: '',
				timestamp: 0,
				year: 0,
				month: 0,
				date: 0,
				day: 0,
				lunar: '',
				holiday: '',
				isToday: false,
				disabled: false,
			} as UXCalendarDate,
	
			timeDatas: [] as UXCalendarDate[],
	
			_calendar: new Calendar() as Calendar,
	
			touches: [] as Touch[],
			selectFirst: false
		}
	},
	props: {
		// 格式化规则
		format: {
			type: String,
			default: ''
		},
		// 值
		value: {
			type: Array,
			default: () : string[] => {
				return [] as string[]
			}
		},
		// 范围
		range: {
			type: Array,
			default: () : string[] => {
				return [] as string[]
			}
		},
		// 日历选择模式
		selectMode: {
			type: String,
			default: 'single'
		},
		// 显示农历
		lunar: {
			type: Boolean,
			default: true
		},
		// 显示节日
		holiday: {
			type: Boolean,
			default: true
		},
		// 滑动翻页
		touch: {
			type: Boolean,
			default: true
		},
		// 主题颜色
		theme: {
			type: String,
			default: $ux.theme.primary
		},
		// 是否禁用
		disabled: {
			type: Boolean,
			default: false
		}
	},
	computed: {
		textStyle() : string {
			return `color: ${$ux.theme.main}`
		},
		weekStyle() : string {
			return `border-bottom: 1rpx solid ${$ux.theme.border}`
		},
		min() : number {
			if (this.range.length >= 2) {
				return $ux.Date.toDate(this.range[0] as string).getTime()
			}
	
			return 0
		},
		max() : number {
			if (this.range.length >= 2) {
				return $ux.Date.toDate(this.range[this.range.length - 1] as string).getTime()
			}
	
			return 0
		},
		date() : string {
			if (this.selectMode == 'muti') {
				if (this.timeDatas.length == 0) {
	
				} else if (this.timeDatas.length == 1) {
					return $ux.Date.fmtDate(this.timeDatas[0].fullDate, 'yyyy年MM月dd日')
				} else {
					return `${$ux.Date.fmtDate(this.timeDatas[0].fullDate, 'yyyy年MM月dd日')} 等${this.timeDatas.length}个日期`
				}
			} else if (this.selectMode == 'range') {
				if (this.timeDatas.length == 0) {
	
				} else if (this.timeDatas.length == 1) {
					return $ux.Date.fmtDate(this.timeDatas[0].fullDate, 'yyyy年MM月dd日')
				} else {
					return `${$ux.Date.fmtDate(this.timeDatas[0].fullDate, 'yyyy年MM月dd日')} ~ ${$ux.Date.fmtDate(this.timeDatas[this.timeDatas.length - 1].fullDate, 'yyyy年MM月dd日')}`
				}
			}
	
			return $ux.Date.fmtDate(this.timeData.fullDate, this.format)
		},
		ele() : Element {
			return this.eleIndex == 0 ? this.month0Ele! : (this.eleIndex == 1 ? this.month1Ele! : this.month2Ele!)
		},
		ctx() : any | null {
			return this.eleIndex == 0 ? this.month0Ctx! : (this.eleIndex == 1 ? this.month1Ctx! : this.month2Ctx!)
		}
	},
	watch: {
		selectMode() {
			this.setDefault()
			this.reset()
		},
		range() {
			this.setDefault()
			this.reset()
		},
		holiday() {
			this.setDefault()
			this.reset()
		},
		lunar() {
			this.setDefault()
			this.reset()
		},
	},
	mounted() {
		uni.createSelectorQuery().in(this).select('.ux-calendar').boundingClientRect().exec((ret) => {
			this.weekEle = this.$refs['week'] as Element
			this.month0Ele = this.$refs['month0'] as Element
			this.month1Ele = this.$refs['month1'] as Element
			this.month2Ele = this.$refs['month2'] as Element
	
			// #ifndef APP
			// @ts-ignore
			this.month0Ctx = uni.createCanvasContext(this.month0ID, this)
			// @ts-ignore
			this.month1Ctx = uni.createCanvasContext(this.month1ID, this)
			// @ts-ignore
			this.month2Ctx = uni.createCanvasContext(this.month2ID, this)
			// #endif
			
			this.setDefault()
			this.reset()
		})
	},
	methods: {
		change() {
			this.$emit('change', {
				value: this.timeDatas
			} as UXCalendarEvent)
		},
		setDefault() {
			if (this.value.length == 0) {
				this.timeData = this._calendar.getDateInfo()
				this.timeDatas = [this.timeData]
			} else {
				if (this.selectMode == 'muti') {
					this.value.forEach((e : any | null) => {
						this.timeData = this._calendar.getDateInfo(e! as string)
						this.timeDatas.push(this.timeData)
					})
				} else if (this.selectMode == 'range') {
					this.value.forEach((e : any | null) => {
						this.timeData = this._calendar.getDateInfo(e! as string)
						this.timeDatas.push(this.timeData)
					})
					this.timeDatas = this._calendar.getDateRange(this.timeDatas)
				} else {
					this.timeData = this._calendar.getDateInfo(this.value[0] as string)
					this.timeDatas = [this.timeData]
				}
			}
		},
		reset() {
			this.coords = []
	
			const time = this._calendar.getDate(this.timeData.fullDate, 0, 'month')
			this.weeks = this._calendar.getWeeks(time.fullDate)
	
			const nextTime = this._calendar.getDate(this.timeData.fullDate, 1, 'month')
			this.nextWeeks = this._calendar.getWeeks(nextTime.fullDate)
	
			const lastTime = this._calendar.getDate(this.timeData.fullDate, -1, 'month')
			this.lastWeeks = this._calendar.getWeeks(lastTime.fullDate)
	
			// #ifdef APP
			this.month0Ele?.getDrawableContext()?.reset()
			this.month1Ele?.getDrawableContext()?.reset()
			this.month2Ele?.getDrawableContext()?.reset()
			// #endif
			
			// #ifndef APP
			// this.month0Ctx?.clearRect()
			// this.month1Ctx?.clearRect()
			// this.month2Ctx?.clearRect()
			// #endif
			
			this.draw()
		},
		eleChange(e : SwiperChangeEvent) {
			let index = e.detail.current
	
			if ((this.eleIndex + 1) % 3 == index) {
				this.nextMonth()
			} else {
				this.preMonth()
			}
	
			this.eleIndex = index
		},
		preYear() {
			this.setDate(-1, 'year')
		},
		nextYear() {
			this.setDate(1, 'year')
		},
		preMonth() {
			this.setDate(-1, 'month')
		},
		nextMonth() {
			this.setDate(1, 'month')
		},
		today() {
			this.setDate(0, 'day')
		},
		setDate(n : number, dt : string) {
			const time = this._calendar.getDate(n == 0 ? '' : this.timeData.fullDate, n, dt)
			this.timeData = this._calendar.getDateInfo(time.fullDate)
	
			if (this.selectMode == 'muti') {
	
			} else if (this.selectMode == 'range') {
	
			} else {
				this.timeDatas = [this.timeData]
			}
	
			setTimeout(() => {
				this.reset()
				this.change()
			}, 300)
		},
		selectDate(e : TouchEvent) : UXCalendarDate | null {
			let rect = this.ele.getBoundingClientRect()
	
			const clientX = e.changedTouches[0].clientX
			const clientY = e.changedTouches[0].clientY
	
			const x = clientX - rect.left
			const y = clientY - rect.top
	
			for (let i = 0; i < this.coords.length; i++) {
				const grid = this.coords[i]
	
				const maxX = grid.x + grid.width
				const maxY = grid.y + grid.height
	
				const isSelect = (grid.x < x && x < maxX) && (grid.y < y && y < maxY)
	
				if (isSelect) {
					return grid.data
				}
			}
	
			return null
		},
		touchstart(e : TouchEvent) {
			if (this.disabled) {
				return
			}
	
			this.touches = e.changedTouches
	
			let date = this.selectDate(e)
	
			if (date != null && this.timeDatas.length > 1) {
				// 选择第一个则后退选择
				if (date.fullDate == this.timeDatas[0].fullDate) {
					this.selectFirst = true
				}
			}
		},
		touchmove(e : TouchEvent) {
			if (this.disabled) {
				return
			}
	
			if (this.selectMode != 'range') {
				return
			}
	
			let date = this.selectDate(e)
	
			if (date != null) {
				this.touchRange(date!)
			}
		},
		touchend(e : TouchEvent) {
			if (this.disabled) {
				return
			}
	
			this.selectFirst = false
	
			if (this.touches.length != 1) {
				return
			}
	
			const dx = e.changedTouches[0].clientX - this.touches[0].clientX
			const dy = e.changedTouches[0].clientY - this.touches[0].clientY
			let dis = Math.sqrt(dx * dx + dy * dy)
	
			if (dis > 5) {
				return
			}
	
			let date = this.selectDate(e)
	
			if (date != null) {
				this.timeData = this._calendar.getDateInfo(date.fullDate)
	
				if (this.selectMode == 'muti') {
					let index = this.timeDatas.findIndex((e : UXCalendarDate) : boolean => e.fullDate == this.timeData.fullDate)
					if (index == -1) {
						this.timeDatas.push(this.timeData)
					} else {
						this.timeDatas.splice(index, 1)
					}
	
					// #ifdef APP
					this.ele.getDrawableContext()!.reset()
					// #endif
					// #ifndef APP
					
					// #endif
					
					this.drawMonth(0, this.ele, this.ctx, this.weeks, date.fullDate, this.timeData.month)
				} else if (this.selectMode == 'range') {
					this.touchRange(date!)
				} else {
					this.timeDatas = [this.timeData]
	
					// #ifdef APP
					this.ele.getDrawableContext()!.reset()
					// #endif
					// #ifndef APP
					
					// #endif
					
					this.drawMonth(0, this.ele, this.ctx, this.weeks, date.fullDate, this.timeData.month)
				}
	
				this.change()
				this.$emit('click', date.fullDate)
			}
		},
		touchRange(date : UXCalendarDate) {
			this.timeData = this._calendar.getDateInfo(date.fullDate)
	
			let index = this.timeDatas.findIndex((e : UXCalendarDate) : boolean => e.fullDate == this.timeData.fullDate)
	
			if (this.selectFirst) {
				if (index == -1) {
					if (date._date.getTime() > this.timeDatas[this.timeDatas.length - 1]._date.getTime()) {
						this.timeDatas = [date, this.timeDatas[this.timeDatas.length - 1]]
						this.selectFirst = false
					} else {
						this.timeDatas.push(this.timeData)
					}
	
					this.redraw(date.fullDate)
				} else {
					if (date.fullDate == this.timeDatas[0].fullDate) {
						return
					}
	
					if (index < this.timeDatas.length) {
						this.timeDatas = this.timeDatas.slice(index, this.timeDatas.length)
	
						this.redraw(date.fullDate)
	
						if (this.timeDatas.length <= 1) {
							this.selectFirst = false
						}
					}
				}
			} else {
				if (index == -1) {
					if (date._date.getTime() < this.timeDatas[0]._date.getTime()) {
						this.timeDatas = [date, this.timeDatas[0]]
					} else {
						this.timeDatas.push(this.timeData)
					}
	
					this.redraw(date.fullDate)
				} else {
					if (date.fullDate == this.timeDatas[0].fullDate) {
						return
					}
					if (date.fullDate == this.timeDatas[this.timeDatas.length - 1].fullDate) {
						return
					}
	
					if (index < this.timeDatas.length) {
						this.timeDatas = this.timeDatas.slice(0, index + 1)
	
						this.redraw(date.fullDate)
					}
				}
			}
		},
		redraw(date : string) {
			this.timeDatas = this._calendar.getDateRange(this.timeDatas)
	
			// #ifdef APP
			this.ele.getDrawableContext()!.reset()
			// #endif
			// #ifndef APP
			
			// #endif
			
			this.drawMonth(0, this.ele, this.ctx, this.weeks, date, this.timeData.month)
	
			this.change()
		},
		draw() {
			this.drawWeek()
			
			let getCtx = (el: Element | null, ctx: any | null): any | null => {
				// #ifdef APP
				return el?.getDrawableContext()
				// #endif
				// #ifndef APP
				return ctx
				// #endif
			}
				
			if (this.eleIndex == 0) {
				this.drawMonth(0, this.month0Ele, getCtx(this.month0Ele, this.month0Ctx) , this.currentWeeks(0), this.timeData.fullDate, this.timeData.month)
				
				this.drawMonth(1, this.month1Ele, getCtx(this.month1Ele, this.month1Ctx), this.currentWeeks(1), '', this.timeData.month + 1)
				
				this.drawMonth(2, this.month2Ele, getCtx(this.month2Ele, this.month2Ctx), this.currentWeeks(2), '', this.timeData.month - 1)
			} else if (this.eleIndex == 1) {
				this.drawMonth(2, this.month0Ele, getCtx(this.month0Ele, this.month0Ctx), this.currentWeeks(0), '', this.timeData.month - 1)
				
				this.drawMonth(0, this.month1Ele, getCtx(this.month1Ele, this.month1Ctx), this.currentWeeks(1), this.timeData.fullDate, this.timeData.month)
				
				this.drawMonth(1, this.month2Ele, getCtx(this.month2Ele, this.month2Ctx), this.currentWeeks(2), '', this.timeData.month + 1)
			} else if (this.eleIndex == 2) {
				this.drawMonth(1, this.month0Ele, getCtx(this.month0Ele, this.month0Ctx), this.currentWeeks(0), '', this.timeData.month + 1)
				
				this.drawMonth(2, this.month1Ele, getCtx(this.month1Ele, this.month1Ctx), this.currentWeeks(1), '', this.timeData.month - 1)
				
				this.drawMonth(0, this.month2Ele, getCtx(this.month2Ele, this.month2Ctx), this.currentWeeks(2), this.timeData.fullDate, this.timeData.month)
			}
		},
		drawWeek() {
			// #ifdef APP
			if (this.weekEle == null) return
				
			let ctx = this.weekEle!.getDrawableContext()!
			
			const width = this.weekEle!.getBoundingClientRect().width / this.weekDays.length
				
			for (let i = 0; i < this.weekDays.length; i++) {
				let left = i * width + 2
				let w = width - 4
				let h = 26
				
				const text = this.weekDays[i]
				let textLeft = w / 2 + left
				let textTop = h / 2 + 6
				
				ctx.font = '12'
				ctx.textAlign = 'center'
				ctx.fillText(text, textLeft, textTop)
				ctx.update()
			}
			// #endif
		},
		drawMonth(weekType : number, ele : Element | null, ctx: any | null, weeks : Array<Array<UXCalendarDate>>, time : string, month : number) {
			if (ele == null || ctx == null) return
			
			const dom = ele!.getBoundingClientRect()
			const width = dom.width / weeks[0].length
			const height = dom.height / weeks.length
			
			// #ifdef APP
			ctx = ctx as DrawableContext
			// #endif
				
			if (time != '') {
				this.coords = []
				// ctx.reset()
			}
			
			// #ifdef APP
			ctx.font = '180px'
			// #endif
			// #ifndef APP
			let dpr = uni.getSystemInfoSync().devicePixelRatio
			ctx.scale(dpr, dpr)
			ctx.setFontSize(180)
			// #endif
			
			ctx.fillStyle = '#f5f5f5'
			ctx.textAlign = 'center'
			ctx.fillText(this.monthText(month), dom.width / 2, dom.height / 2 + 65)
				
			for (let weekIndex = 0; weekIndex < weeks.length; weekIndex++) {
				for (let dayIndex = 0; dayIndex < weeks[weekIndex].length; dayIndex++) {
					const day = weeks[weekIndex][dayIndex]
				
					let left = dayIndex * width
					let top = weekIndex * height
				
					let padding = 3
				
					let dayWidth = width
					let dayHeight = height
				
					let text = day.date.toString()
					let textLeft = dayIndex * width + (width / 2)
					let textTop = weekIndex * height + (this.lunar ? 22 : 29)
				
					let selected = this.daySelected(day, time)
					
					// #ifdef APP
					ctx.font = '16px'
					// #endif
					// #ifndef APP
					ctx.setFontSize(16)
					// #endif
					
					ctx.textAlign = 'center'
					
					let drawText = () => {
						ctx.fillStyle = this.dayColor(day)
						ctx.fillText(text, textLeft, textTop)
					}
				
					let drawCircle = () => {
						ctx.beginPath()
						ctx.arc(left + (width / 2), top + (height / 2), 20, 0, Math.PI * 2)
						ctx.closePath()
				
						ctx.fillStyle = this.theme
						ctx.fill()
					}
				
					let drawStart = () => {
						ctx.fillStyle = $ux.Color.hexToRgba(this.theme, 0.4)
				
						if (this.timeDatas.length > 1) {
							let t = top + padding
							let h = height - padding * 2
							ctx.fillRect(left + width / 2, t, width / 2, h)
						}
				
						ctx.beginPath()
						ctx.arc(left + (width / 2), top + (height / 2), 20, 0, Math.PI * 2)
						ctx.closePath()
				
						ctx.fillStyle = this.theme
						ctx.fill()
					}
				
					let drawEnd = () => {
						ctx.fillStyle = $ux.Color.hexToRgba(this.theme, 0.4)
				
						if (this.timeDatas.length > 1) {
							let t = top + padding
							let h = height - padding * 2
							ctx.fillRect(left, t, width / 2, h)
						}
				
						ctx.beginPath()
						ctx.arc(left + (width / 2), top + (height / 2), 20, 0, Math.PI * 2)
						ctx.closePath()
				
						ctx.fillStyle = this.theme
						ctx.fill()
					}
				
					let drawRange = () => {
						let t = top + padding
						let w = width
						let h = height - padding * 2
						
						ctx.fillStyle = $ux.Color.hexToRgba(this.theme, 0.4)
						
						if (day.day == 1) {
							ctx.beginPath()
							ctx.moveTo(left, t)
							ctx.lineTo(left + w / 2, t)
							ctx.bezierCurveTo(left + w, t + h / 2 - 16, left + w, t + h / 2 + 16, left + w / 2, t + h)
							ctx.lineTo(left, t + h)
							ctx.closePath()
							ctx.fill()
						} else if (day.day == 2) {
							ctx.beginPath()
							ctx.moveTo(left + w, t)
							ctx.lineTo(left + w / 2, t)
							ctx.bezierCurveTo(left, t + h / 2 - 16, left, t + h / 2 + 16, left + w / 2, t + h)
							ctx.lineTo(left + w, t + h)
							ctx.closePath()
							ctx.fill()
						} else {
							ctx.fillRect(left, t, w, h)
						}
					}
				
					// 日期是否禁用
					if (this.dayDisabled(day)) {
						drawText()
					} else {
						if (selected) {
							if (this.selectMode == 'range') {
								if (day.fullDate == this.timeDatas[0].fullDate) {
									drawStart()
								} else if (day.fullDate == this.timeDatas[this.timeDatas.length - 1].fullDate) {
									drawEnd()
								} else {
									drawRange()
								}
							} else {
								drawCircle()
							}
				
							drawText()
						} else {
							drawText()
						}
				
						if (weekType == 0) {
							this.coords.push({
								x: left,
								y: top,
								width: dayWidth,
								height: dayHeight,
								data: day
							} as CoordsType)
						}
					}
				
					if (this.lunar) {
						let lunarLeft = dayIndex * width + (width / 2)
						let lunarTop = weekIndex * height + (height / 2) + 13
				
						// #ifdef APP
						ctx.font = '9px'
						// #endif
						// #ifndef APP
						ctx.setFontSize(9)
						// #endif
						
						ctx.textAlign = 'center'
						ctx.fillStyle = this.dayColor(day)
						ctx.fillText(this.luarText(day), lunarLeft, lunarTop)
					}
				}
			}
			
			// #ifdef APP
			ctx.update()
			// #endif
			// #ifndef APP
			ctx.draw()
			// #endif
		},
		currentWeeks(index: number): Array<Array<UXCalendarDate>> {
			if (this.eleIndex == 0) {
				switch (index){
					case 0:
						return this.weeks
					case 1:
						return this.nextWeeks
					case 2:
						return this.lastWeeks
				}
			} else if (this.eleIndex == 1) {
				switch (index){
					case 0:
						return this.lastWeeks
					case 1:
						return this.weeks
					case 2:
						return this.nextWeeks
				}
			} else if (this.eleIndex == 2) {
				switch (index){
					case 0:
						return this.nextWeeks
					case 1:
						return this.lastWeeks
					case 2:
						return this.weeks
				}
			}
			
			return this.weeks
		},
		currentTime(index: number): string {
			if (this.eleIndex == 0) {
				return index == 0 ? this.timeData.fullDate : ''
			} else if (this.eleIndex == 1) {
				return index == 1 ? this.timeData.fullDate : ''
			} else if (this.eleIndex == 2) {
				return index == 2 ? this.timeData.fullDate : ''
			}
			
			return ''
		},
		monthText(month: number): string {
			return `${month == 0 ? 12 : (month == 13 ? 1 : month)}`.padStart(2, '0')
		},
		luarText(day: UXCalendarDate): string {
			let lunar = day.lunar
			
			if (this.holiday && day.holiday != '') {
				lunar = day.holiday
			}
			
			return lunar
		},
		daySelected(day: UXCalendarDate, time: string): boolean {
			let selected = false
			
			if (this.selectMode == 'single') {
				selected = time == day.fullDate
			} else {
				let index = this.timeDatas.findIndex((e : UXCalendarDate) : boolean => e.fullDate == day.fullDate)
				selected = index != -1
			}
			
			return selected
		},
		dayDisabled(day: UXCalendarDate): boolean {
			let disabled = false
			if (this.min > 0 && this.max > 0) {
				disabled = day.timestamp < this.min || day.timestamp > this.max
			}
			if (day.disabled || disabled) {
				return true
			}
			
			return false
		},
		dayColor(day: UXCalendarDate) : string {
			let color = 'fff'
			
			if(this.dayDisabled(day)) {
				color = '#ccc'
			} else if(this.daySelected(day, '')) {
				color = '#fff'
			} else {
				color = day.isToday ? $ux.theme.error! : '#666'
			}
			
			return color
		},
		dayStyle(day: UXCalendarDate) : string {
			return `color: ${this.dayColor(day)}`
		},
		selectedStyle(day: UXCalendarDate, time: string) : string {
			return `background-color: ${this.daySelected(day, time)? this.theme : 'transparent'}`
		}
	}
})